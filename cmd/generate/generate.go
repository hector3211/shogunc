package generate

import (
	"bufio"
	"errors"
	"fmt"
	"go/format"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"shogunc/internal/codegen"
	"shogunc/internal/parser"
	"shogunc/internal/types"
	"strings"

	"gopkg.in/yaml.v3"
)

// Note: Debug feature
type ErrMsg string

type ErrorLogger struct {
	ErrMsg   ErrMsg
	Position int
}

type Driver string

const (
	SQLITE   Driver = "sqlite3"
	POSTGRES Driver = "postgres"
)

// schema: schema.sql
// queries: queries
// driver: sqlite3
// output: /tmp/generated.sql.go

type SqlConfig struct {
	Schema  string `yaml:"schema"`
	Queries string `yaml:"queries"`
	Driver  Driver `yaml:"driver"`
	Output  string `yaml:"output,omitempty"`
}

type ShogunConfig struct {
	Sql SqlConfig `yaml:"sql"`
}

type Generator struct {
	Config      ShogunConfig
	Types       map[string]any
	Imports     []string
	TagRegex    *regexp.Regexp
	OutputCache *strings.Builder
}

func NewGenerator() *Generator {
	return &Generator{
		Config: ShogunConfig{
			Sql: SqlConfig{
				Queries: "",
				Schema:  "",
				Driver:  "",
				// Output:  fmt.Sprintf("%s/generated.sql.go",cwd),
				Output: "../../tmp/internal/generated",
				// Todo: turn to empty string
			},
		},
		Types:       make(map[string]any),
		Imports:     []string{"context", "time"},
		TagRegex:    regexp.MustCompile(`--\s*name:\s*(\w+)\s*:(\w+)`),
		OutputCache: &strings.Builder{},
	}
}

func (g *Generator) Execute(cwd string) error {
	if !g.hasConfig(cwd) {
		return fmt.Errorf("no shogunc.yml exists CWD: %s", cwd)
	}

	if err := g.loadConfig(cwd); err != nil {
		return err
	}

	if err := g.LoadSchema(); err != nil {
		return err
	}

	if err := g.writeOutput(); err != nil {
		return err
	}

	if err := g.LoadSqlFiles(); err != nil {
		return err
	}

	// Generate and write the db.go file
	_, err := codegen.GenerateGoDb(filepath.Join(g.Config.Sql.Output, "db.go"), string(g.Config.Sql.Driver))
	return err
}

func (g Generator) hasConfig(cwd string) bool {
	_, err := os.ReadFile(filepath.Join(cwd, "shogunc.yml"))
	return err == nil
}

func (g *Generator) loadConfig(cwd string) error {
	path := filepath.Join(cwd, "shogunc.yml")

	configFile, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("[GENERATE] failed to read config file at %s: %w", path, err)
	}

	var config ShogunConfig
	if err := yaml.Unmarshal(configFile, &config); err != nil {
		return fmt.Errorf("[GENERATE] invalid config: %v", err)
	}

	if config.Sql.Queries == "" {
		return errors.New("[GENERATE] failed reading queries path")
	}
	if config.Sql.Schema == "" {
		return errors.New("[GENERATE] failed reading schema path")
	}
	if config.Sql.Driver == "" {
		return errors.New("[GENERATE] failed reading sql driver")
	}
	if config.Sql.Output == "" {
		return errors.New("[GENERATE] failed reading sql config output")
	}

	g.Config.Sql = config.Sql
	return nil
}

func (g *Generator) LoadSchema() error {
	fileContents, err := os.ReadFile(g.Config.Sql.Schema)
	if err != nil {
		return err
	}

	lexer := parser.NewLexer(string(fileContents))
	ast := parser.NewAst(lexer)
	if err := ast.ParseSchema(); err != nil {
		return err
	}

	var genContent strings.Builder

	projectName := "shogunc"
	genContent.WriteString(fmt.Sprintf("// Code generated by %s. DO NOT EDIT.\n", projectName))

	genContent.WriteString("package db\n\n")

	// For schema files, only include necessary imports
	genContent.WriteString("import (\n")
	genContent.WriteString(fmt.Sprintf("\t%q\n", "time"))
	genContent.WriteString(")\n\n")

	for _, datatype := range ast.Statements {
		switch t := datatype.(type) {
		case *parser.Table:
			if _, ok := g.Types[t.Name]; !ok {
				g.Types[t.Name] = t
			}

			selectableType, err := codegen.GenerateTableType(t)
			if err != nil {
				return fmt.Errorf("[GENERATE] failed generating table type %v", err)
			}

			var buf strings.Builder
			if err := format.Node(&buf, token.NewFileSet(), selectableType); err != nil {
				return fmt.Errorf("failed to format selectable type: %w", err)
			}
			genContent.WriteString(buf.String() + "\n\n")

			insertableType, err := codegen.GenerateInsertableTableType(t)
			if err != nil {
				return fmt.Errorf("[GENERATE] failed generating insertable table type %v", err)
			}
			buf.Reset()

			if err := format.Node(&buf, token.NewFileSet(), insertableType); err != nil {
				return fmt.Errorf("failed to format insertable type: %w", err)
			}
			genContent.WriteString(buf.String() + "\n")

		case *parser.Enum:
			if _, ok := g.Types[t.Name]; !ok {
				g.Types[t.Name] = t
			}
			typeDecl, constDecl, err := codegen.GenerateEnumType(t)
			if err != nil {
				return fmt.Errorf("[GENERATE] failed generating enum type %v", err)
			}

			var buf strings.Builder
			if err := format.Node(&buf, token.NewFileSet(), typeDecl); err != nil {
				return fmt.Errorf("failed to format enum type: %w", err)
			}
			genContent.WriteString(buf.String() + "\n\n")

			buf.Reset()
			if err := format.Node(&buf, token.NewFileSet(), constDecl); err != nil {
				return fmt.Errorf("failed to format enum const: %w", err)
			}
			genContent.WriteString(buf.String() + "\n")
		default:
			return errors.New("[GENERATE] load schema failed with invalid type")
		}
	}

	if genContent.Len() == 0 {
		return errors.New("[GENERATE] failed generating SQL types")
	}

	g.OutputCache.Write([]byte(genContent.String()))
	return nil
}

func (g *Generator) LoadSqlFiles() error {
	cwd, err := os.Getwd()
	if err != nil {
		return err
	}
	directory := filepath.Join(cwd, string(g.Config.Sql.Queries))
	dirEntries, err := os.ReadDir(directory)
	if err != nil {
		return err
	}

	for _, entry := range dirEntries {
		if entry.IsDir() {
			continue // Skip directories
		}
		if !strings.HasSuffix(entry.Name(), ".sql") {
			continue
		}

		fullPath := filepath.Join(directory, entry.Name())
		file, err := os.Open(fullPath)
		if err != nil {
			return fmt.Errorf("[GENERATE] failed to open %s: %v", fullPath, err)
		}
		defer file.Close()

		err = g.parseSqlFile(file, entry.Name())
		if err != nil {
			return fmt.Errorf("[GENERATE] failed to parse %s: %v", fullPath, err)
		}
	}
	return nil
}

func (g *Generator) parseSqlFile(file *os.File, fileName string) error {
	queryBlocks, err := g.extractSqlBlocks(file, file.Name())
	if err != nil {
		return err
	}

	var genContent strings.Builder
	for _, qb := range queryBlocks {
		lexer := parser.NewLexer(qb.SQL)
		ast := parser.NewAst(lexer)
		if err := ast.Parse(); err != nil {
			return fmt.Errorf("[GENERATE] failed parsing %s: %w", qb.Name, err)
		}

		dataType := g.inferType(qb.SQL)
		if dataType == nil {
			return fmt.Errorf("[GENERATE] failed infering type for %s\n SQL: %s", qb.Name, qb.SQL)
		}

		if len(ast.Statements) == 0 {
			return errors.New("[GENERATE] no SQL statements to parse")
		}

		funcGen := codegen.NewGoGenerator(g.Types, &qb)
		for _, statement := range ast.Statements {
			funcDecl, paramStruct, err := funcGen.Generate(statement)
			if err != nil {
				return err
			}

			// Convert AST nodes to Go code strings
			if paramStruct != nil {
				var buf strings.Builder
				if err := format.Node(&buf, token.NewFileSet(), paramStruct); err != nil {
					return fmt.Errorf("failed to format param struct: %w", err)
				}
				genContent.WriteString(buf.String() + "\n\n")
			}
			if funcDecl != nil {
				var buf strings.Builder
				if err := format.Node(&buf, token.NewFileSet(), funcDecl); err != nil {
					return fmt.Errorf("failed to format function: %w", err)
				}
				genContent.WriteString(buf.String() + "\n\n")
			}
		}
	}
	if genContent.String() == "" {
		return errors.New("[GENERATE] failed generating code")
	}

	// Generate separate file for this SQL file
	outputFileName := strings.TrimSuffix(fileName, ".sql") + ".sql.go"
	outputPath := filepath.Join(g.Config.Sql.Output, outputFileName)

	// Create package header
	var fullContent strings.Builder
	projectName := "shogunc"
	fullContent.WriteString(fmt.Sprintf("// Code generated by %s. DO NOT EDIT.\n", projectName))

	fullContent.WriteString("package db\n\n")

	// For SQL query files, include necessary imports
	fullContent.WriteString("import (\n")
	fullContent.WriteString(fmt.Sprintf("\t%q\n", "context"))
	fullContent.WriteString(")\n\n")

	fullContent.WriteString(genContent.String())

	// Create the directory if it doesn't exist
	if err := os.MkdirAll(g.Config.Sql.Output, 0755); err != nil {
		return fmt.Errorf("[GENERATE] failed to create directory %s: %w", g.Config.Sql.Output, err)
	}

	return os.WriteFile(outputPath, []byte(fullContent.String()), 0644)
}

func (g *Generator) extractSqlBlocks(file *os.File, fileName string) ([]types.QueryBlock, error) {
	scanner := bufio.NewScanner(file)
	var blocks []types.QueryBlock

	var current *types.QueryBlock
	var sqlBuilder strings.Builder

	// TODO: clean this logic up
	for scanner.Scan() {
		line := scanner.Text()
		// Match on shogunc tag
		if matches := g.TagRegex.FindStringSubmatch(line); matches != nil {
			if current != nil {
				current.SQL = sqlBuilder.String()
				blocks = append(blocks, *current)
				sqlBuilder.Reset()
			}
			// Initialize Tag with name & type
			current = &types.QueryBlock{
				Name:     strings.ToUpper(matches[1][:1]) + matches[1][1:],
				Type:     types.Type(matches[2]),
				Filename: fileName,
			}
			continue
		}

		if current != nil {
			sqlBuilder.WriteString(line)
			sqlBuilder.WriteRune('\n')
		}
	}

	// Last SQL statement
	if current != nil {
		current.SQL = sqlBuilder.String()
		blocks = append(blocks, *current)
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return blocks, nil
}

func (g Generator) writeOutput() error {
	if g.OutputCache.Len() == 0 {
		return errors.New("[GENERATE] no content to write")
	}

	// Create the directory if it doesn't exist
	if err := os.MkdirAll(g.Config.Sql.Output, 0755); err != nil {
		return fmt.Errorf("[GENERATE] failed to create directory %s: %w", g.Config.Sql.Output, err)
	}

	// Write schema to schema.sql.go
	schemaOutputPath := filepath.Join(g.Config.Sql.Output, "schema.sql.go")
	return os.WriteFile(schemaOutputPath, []byte(g.OutputCache.String()), 0644)
}

func (g Generator) inferType(sql string) any {
	tokens := strings.Fields(sql)
	for _, k := range tokens {
		key := strings.Trim(k, ";,()")
		if datType, ok := g.Types[key]; ok {
			return datType
		}
	}
	return nil
}
